name: Input Required Label

on:
  issues:
    types: [opened, edited, labeled, unlabeled]
  issue_comment:
    types: [created, edited, deleted]
  pull_request:
    types: [opened, edited, labeled, unlabeled, synchronize, ready_for_review]
  pull_request_review:
    types: [submitted, edited, dismissed]
  pull_request_review_comment:
    types: [created, edited, deleted]
  schedule:
    # Run every 4 hours to catch any missed updates
    - cron: '0 */4 * * *'
  workflow_dispatch:
    # Allow manual triggering

jobs:
  manage-input-required:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      contents: read

    steps:
      - name: Update input required label for issues and PRs
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Function to check if content is authored by Claude
            function isClaudeContent(text) {
              return text && text.includes('âœ¨ Content generated by Claude AI.');
            }

            // Function to get the last substantive comment (ignore automated bot comments)
            function getLastSubstantiveComment(comments) {
              // Filter out dependency status comments and other automated comments
              const substantiveComments = comments.filter(c =>
                !c.body.includes('## ðŸ”— Dependency Status') &&
                !c.body.includes('*This comment is automatically updated by')
              );

              return substantiveComments.length > 0
                ? substantiveComments[substantiveComments.length - 1]
                : null;
            }

            // Function to update input required label
            async function updateInputRequiredLabel(issueNumber, needsHumanInput, currentLabels) {
              const hasLabel = currentLabels.includes('input required');

              if (needsHumanInput && !hasLabel) {
                // Add label - human needs to respond
                try {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    labels: ['input required']
                  });
                  console.log(`âœ“ Added 'input required' label to #${issueNumber}`);
                } catch (error) {
                  console.log(`âœ— Failed to add 'input required' label to #${issueNumber}: ${error.message}`);
                }
              } else if (!needsHumanInput && hasLabel) {
                // Remove label - Claude needs to respond
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    name: 'input required'
                  });
                  console.log(`âœ“ Removed 'input required' label from #${issueNumber}`);
                } catch (error) {
                  // Ignore errors if label doesn't exist
                  if (error.status !== 404) {
                    console.log(`âœ— Failed to remove 'input required' label from #${issueNumber}: ${error.message}`);
                  }
                }
              }
              // If label state is already correct, do nothing (silent)
            }

            // Main processing logic
            console.log('Starting input required label check...');

            // Get all open issues with 'discuss' or 'design' labels
            const discussIssuesResponse = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: 'discuss',
              per_page: 100
            });

            const designIssuesResponse = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: 'design',
              per_page: 100
            });

            // Combine and deduplicate issues (some might have both labels)
            const issuesMap = new Map();
            [...discussIssuesResponse.data, ...designIssuesResponse.data].forEach(issue => {
              issuesMap.set(issue.number, issue);
            });

            const issues = Array.from(issuesMap.values());
            console.log(`Found ${issues.length} open issues with 'discuss' or 'design' label`);

            // Process each issue
            for (const issue of issues) {
              console.log(`\nProcessing issue #${issue.number}: ${issue.title}`);

              // Get all comments for the issue
              const commentsResponse = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: issue.number
              });

              const lastSubstantiveComment = getLastSubstantiveComment(commentsResponse.data);

              let needsHumanInput = false;

              if (lastSubstantiveComment) {
                // Check if last comment is from Claude
                needsHumanInput = isClaudeContent(lastSubstantiveComment.body);
                console.log(`  Last substantive comment by: ${lastSubstantiveComment.user.login}`);
                console.log(`  Is Claude content: ${needsHumanInput}`);
              } else if (issue.body) {
                // No comments, check if issue body is from Claude
                needsHumanInput = isClaudeContent(issue.body);
                console.log(`  No substantive comments, checking issue body`);
                console.log(`  Is Claude content: ${needsHumanInput}`);
              } else {
                // No comments and no body - default to needing human input
                needsHumanInput = false;
                console.log(`  No content to check, default to human needs to respond`);
              }

              // Get current labels
              const currentLabels = issue.labels.map(l => l.name);

              // Update label
              await updateInputRequiredLabel(issue.number, needsHumanInput, currentLabels);
            }

            // Cleanup: Remove 'input required' label from issues without 'discuss' or 'design' labels
            console.log('\nChecking for issues with "input required" label but no "discuss" or "design" label...');
            const inputRequiredIssuesResponse = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: 'input required',
              per_page: 100
            });

            for (const issue of inputRequiredIssuesResponse.data) {
              // Skip pull requests - they're handled in the PR section below
              if (issue.pull_request) continue;

              const labelNames = issue.labels.map(l => l.name);
              const hasDiscussOrDesign = labelNames.includes('discuss') || labelNames.includes('design');

              if (!hasDiscussOrDesign) {
                console.log(`\nRemoving 'input required' label from #${issue.number} (no discuss/design label)`);
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: issue.number,
                    name: 'input required'
                  });
                  console.log(`âœ“ Removed 'input required' label from #${issue.number}`);
                } catch (error) {
                  if (error.status !== 404) {
                    console.log(`âœ— Failed to remove 'input required' label from #${issue.number}: ${error.message}`);
                  }
                }
              }
            }

            // Process PRs with 'claude' label
            console.log('\n\nProcessing PRs with "claude" label...');
            const claudePRsResponse = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            // Filter for PRs with 'claude' label
            const claudePRs = claudePRsResponse.data.filter(pr =>
              pr.labels.some(label => label.name === 'claude')
            );

            console.log(`Found ${claudePRs.length} open PRs with 'claude' label`);

            for (const pr of claudePRs) {
              console.log(`\nProcessing PR #${pr.number}: ${pr.title}`);

              // Skip draft PRs
              if (pr.draft) {
                console.log(`  Skipping draft PR`);
                continue;
              }

              // Check for Claude footer and add if missing
              const claudeFooter = 'âœ¨ Content generated by Claude AI.';
              const hasFooter = pr.body && pr.body.includes(claudeFooter);

              if (!hasFooter) {
                console.log(`  Footer missing - adding to PR description`);
                const separator = pr.body ? '\n\n---\n' : '---\n';
                const newBody = (pr.body || '') + separator + claudeFooter;

                try {
                  await github.rest.pulls.update({
                    owner,
                    repo,
                    pull_number: pr.number,
                    body: newBody
                  });
                  // Update local pr.body so subsequent checks see the new content
                  pr.body = newBody;
                  console.log(`  âœ“ Added Claude footer to PR #${pr.number}`);
                } catch (error) {
                  console.log(`  âœ— Failed to add footer to PR #${pr.number}: ${error.message}`);
                }
              } else {
                console.log(`  Footer already present`);
              }

              try {
                // Collect all interactions with timestamps
                const interactions = [];

                // 1. Get issue comments (general PR comments)
                const commentsResponse = await github.rest.issues.listComments({
                  owner,
                  repo,
                  issue_number: pr.number
                });

                commentsResponse.data.forEach(comment => {
                  // Skip automated comments
                  if (!comment.body.includes('## ðŸ”— Dependency Status') &&
                      !comment.body.includes('*This comment is automatically updated by')) {
                    interactions.push({
                      type: 'comment',
                      date: new Date(comment.created_at),
                      body: comment.body,
                      user: comment.user.login
                    });
                  }
                });

                // 2. Get review comments (line-specific comments)
                const reviewCommentsResponse = await github.rest.pulls.listReviewComments({
                  owner,
                  repo,
                  pull_number: pr.number
                });

                reviewCommentsResponse.data.forEach(comment => {
                  interactions.push({
                    type: 'review_comment',
                    date: new Date(comment.created_at),
                    body: comment.body,
                    user: comment.user.login
                  });
                });

                // 3. Get reviews
                const reviewsResponse = await github.rest.pulls.listReviews({
                  owner,
                  repo,
                  pull_number: pr.number
                });

                reviewsResponse.data.forEach(review => {
                  // Only include reviews with a body (not just state changes)
                  if (review.body) {
                    interactions.push({
                      type: 'review',
                      date: new Date(review.submitted_at),
                      body: review.body,
                      user: review.user.login
                    });
                  }
                });

                // Sort interactions by date (oldest to newest)
                interactions.sort((a, b) => a.date - b.date);

                let needsHumanInput = false;

                if (interactions.length > 0) {
                  // Get the most recent interaction
                  const lastInteraction = interactions[interactions.length - 1];
                  needsHumanInput = isClaudeContent(lastInteraction.body);
                  console.log(`  Last interaction type: ${lastInteraction.type}`);
                  console.log(`  Last interaction by: ${lastInteraction.user}`);
                  console.log(`  Is Claude content: ${needsHumanInput}`);
                } else if (pr.body) {
                  // No interactions, check if PR body is from Claude
                  needsHumanInput = isClaudeContent(pr.body);
                  console.log(`  No interactions, checking PR body`);
                  console.log(`  Is Claude content: ${needsHumanInput}`);
                } else {
                  // No interactions and no body - default to not needing human input
                  needsHumanInput = false;
                  console.log(`  No content to check, default to Claude needs to respond`);
                }

                // Get current labels
                const currentLabels = pr.labels.map(l => l.name);

                // Never add 'input required' on PRs with technical issues that need immediate attention
                // Merge conflicts and failing checks should always be resolved, regardless of discussion state
                const hasTechnicalIssue = currentLabels.includes('merge-conflict') || currentLabels.includes('failing checks');
                if (hasTechnicalIssue) {
                  needsHumanInput = false;
                  console.log(`  Technical issue detected (${currentLabels.filter(l => l === 'merge-conflict' || l === 'failing checks').join(', ')}) - ensuring 'input required' is not set`);
                }

                // Update label
                await updateInputRequiredLabel(pr.number, needsHumanInput, currentLabels);
              } catch (error) {
                console.log(`âœ— Error processing PR #${pr.number}: ${error.message}`);
                console.log(`  Skipping this PR and continuing with next one`);
                // Continue with next PR instead of failing the entire workflow
                continue;
              }
            }

            // Cleanup: Remove 'input required' label from PRs without 'claude' label
            console.log('\nChecking for PRs with "input required" label but no "claude" label...');
            const allPRsResponse = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            const inputRequiredPRs = allPRsResponse.data.filter(pr =>
              pr.labels.some(label => label.name === 'input required')
            );

            for (const pr of inputRequiredPRs) {
              const labelNames = pr.labels.map(l => l.name);
              const hasClaude = labelNames.includes('claude');

              if (!hasClaude) {
                console.log(`\nRemoving 'input required' label from PR #${pr.number} (no claude label)`);
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pr.number,
                    name: 'input required'
                  });
                  console.log(`âœ“ Removed 'input required' label from PR #${pr.number}`);
                } catch (error) {
                  if (error.status !== 404) {
                    console.log(`âœ— Failed to remove 'input required' label from PR #${pr.number}: ${error.message}`);
                  }
                }
              }
            }

            console.log('\nâœ“ Input required label check complete');
