name: Failing Checks Label

on:
  check_suite:
    types: [completed]
  schedule:
    # Run every 4 hours to catch any missed updates
    - cron: '0 */4 * * *'
  workflow_dispatch:
    # Allow manual triggering

jobs:
  manage-failing-checks:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      checks: read
      contents: read

    steps:
      - name: Update failing checks label for PRs
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Function to update failing checks label
            async function updateFailingChecksLabel(prNumber, hasFailures, currentLabels) {
              const hasLabel = currentLabels.includes('failing checks');

              if (hasFailures && !hasLabel) {
                // Add label - PR has failing checks
                try {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: prNumber,
                    labels: ['failing checks']
                  });
                  console.log(`✓ Added 'failing checks' label to PR #${prNumber}`);
                } catch (error) {
                  console.log(`✗ Failed to add 'failing checks' label to PR #${prNumber}: ${error.message}`);
                }
              } else if (!hasFailures && hasLabel) {
                // Remove label - all checks passing
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: prNumber,
                    name: 'failing checks'
                  });
                  console.log(`✓ Removed 'failing checks' label from PR #${prNumber}`);
                } catch (error) {
                  if (error.status !== 404) {
                    console.log(`✗ Failed to remove 'failing checks' label from PR #${prNumber}: ${error.message}`);
                  }
                }
              }
              // If label state is already correct, do nothing (silent)
            }

            // Main processing logic
            console.log('Starting failing checks label update...');

            // Get all open PRs
            const { data: allPRs } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });

            // Filter for PRs with 'claude' label
            const claudePRs = allPRs.filter(pr =>
              pr.labels.some(label => label.name === 'claude')
            );

            console.log(`Found ${claudePRs.length} open PRs with 'claude' label`);

            // Process each PR
            for (const pr of claudePRs) {
              console.log(`\nProcessing PR #${pr.number}: ${pr.title}`);

              try {
                // Get check runs for the PR's head commit
                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: pr.head.sha,
                  per_page: 100
                });

                const runs = checkRuns.check_runs;

                // Skip this workflow's own check run to avoid self-referencing
                const relevantRuns = runs.filter(run => run.name !== 'manage-failing-checks');

                if (relevantRuns.length === 0) {
                  console.log(`  No check runs found (excluding self), skipping`);
                  continue;
                }

                // Check if any checks are still in progress
                const pendingRuns = relevantRuns.filter(run => run.status !== 'completed');
                if (pendingRuns.length > 0) {
                  console.log(`  ${pendingRuns.length} check(s) still in progress, skipping`);
                  continue;
                }

                // Check for failures
                const failedRuns = relevantRuns.filter(run =>
                  run.conclusion === 'failure' || run.conclusion === 'timed_out'
                );

                const hasFailures = failedRuns.length > 0;

                console.log(`  Total checks: ${relevantRuns.length}, Failed: ${failedRuns.length}`);
                if (hasFailures) {
                  console.log(`  Failing checks: ${failedRuns.map(r => r.name).join(', ')}`);
                }

                // Get current labels
                const currentLabels = pr.labels.map(l => l.name);

                // Update label
                await updateFailingChecksLabel(pr.number, hasFailures, currentLabels);
              } catch (error) {
                console.log(`✗ Failed to process PR #${pr.number}: ${error.message}`);
                console.log(`  This may be a transient API error. The PR will be checked again on the next run.`);
                continue;
              }
            }

            console.log('\n✓ Failing checks label update complete');
